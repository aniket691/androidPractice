package com.example.androidpractice

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.AttributeSet
import android.view.*
import android.widget.AdapterView
import com.example.androidpractice.databinding.ActivityContexualMenuBinding

class ContexualMenuActivity : AppCompatActivity() {

    //    The line private lateinit var binding: ActivityContexualMenuBinding declares a lateinit variable named binding of type ActivityContexualMenuBinding.
//    Here's what each component means:
//    private is an access modifier that specifies that the variable is private and can only be accessed within the scope of the class where it is declared.
//    lateinit is a keyword in Kotlin that allows you to declare a non-null variable without initializing it immediately. It indicates that the variable will be assigned a value later before it is accessed.
//    var indicates that binding is a mutable variable, meaning its value can be changed after initialization.
//    binding is the name of the variable.
//    ActivityContexualMenuBinding refers to the generated binding class for an activity layout file called activity_contextual_menu.xml (or similar). The specific name of the binding class is derived from the layout file name by converting it to PascalCase and appending "Binding" to it. The binding class is generated by the Android Data Binding library or View Binding library, depending on the binding framework you are using in your project.
//    By declaring binding as ActivityContexualMenuBinding and using lateinit, you are indicating that binding will be assigned a value at a later point in the code, but it doesn't need to be initialized immediately when the variable is declared.
    private lateinit var binding: ActivityContexualMenuBinding

    //    The line private var actionMode: ActionMode? = null declares a variable named actionMode of type ActionMode?(means can hold null value) and initializes it with null.
//    Here's the breakdown of the line:
//    private is an access modifier that specifies that the variable is private and can only be accessed within the scope of the class where it is declared.
//    var indicates that actionMode is a mutable variable, meaning its value can be changed.
//    actionMode is the name of the variable.
//    ActionMode? is the type declaration. ActionMode? is a nullable type, denoted by the ? symbol, meaning it can hold a value of the ActionMode class or be assigned null.
//    = null assigns null as the initial value of the actionMode variable.
    private var actionMode: ActionMode? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityContexualMenuBinding.inflate(layoutInflater)
        val view = binding.root
        setContentView(view)

        binding.button.setOnClickListener() { view ->
            // Called when the user long-clicks on button
            when (actionMode) {
                null -> {
                    // Start the CAB using the ActionMode.Callback defined above
                    actionMode = this?.startActionMode(actionModeCallback)
                    view.isSelected = true
                    true
                }
                else -> false
            }
        }
    }


    override fun onCreateContextMenu(
        menu: ContextMenu, v: View,
        menuInfo: ContextMenu.ContextMenuInfo
    ) {
        super.onCreateContextMenu(menu, v, menuInfo)
        val inflater: MenuInflater = menuInflater
        inflater.inflate(R.menu.contexual_menu, menu)
    }

    override fun onCreateView(name: String, context: Context, attrs: AttributeSet): View? {
        return super.onCreateView(name, context, attrs)

    }

    override fun onContextItemSelected(item: MenuItem): Boolean {
        val info = item.menuInfo as AdapterView.AdapterContextMenuInfo
        return when (item.itemId) {
            R.id.new_game -> {
//                editNote(info.id)
                true
            }
            R.id.help -> {
//                deleteNote(info.id)
                true
            }
            else -> super.onContextItemSelected(item)
        }
    }

    private val actionModeCallback = object : ActionMode.Callback {
        // Called when the action mode is created; startActionMode() was called
        override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
            // Inflate a menu resource providing context menu items
            val inflater: MenuInflater = mode.menuInflater
            inflater.inflate(R.menu.contexual_menu, menu)
            return true
        }

        // Called each time the action mode is shown. Always called after onCreateActionMode, but
        // may be called multiple times if the mode is invalidated.
        override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
            return false // Return false if nothing is done
        }

        // Called when the user selects a contextual menu item
        override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
            return when (item.itemId) {
                R.id.new_game -> {
//                    shareCurrentItem()
                    mode.finish() // Action picked, so close the CAB
                    true
                }
                else -> false
            }
        }

        // Called when the user exits the action mode
        override fun onDestroyActionMode(mode: ActionMode) {
            //if we want to call contexual menu again and again after destroying it we have to set it null
            actionMode = null
        }
    }
}